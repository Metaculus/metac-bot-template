import sys
import pathlib
from typing import List, Dict, Any, Optional, Callable  # Added Callable for agent_class

from pydantic import BaseModel, Field

# To import from root agent_sdk.py and forecasting_tools.py
# This assumes the script is run from a context where the project root is in sys.path
# For robustness in different execution contexts, absolute imports or path manipulation might be needed
# For now, we rely on the typical project structure where the root is added to PYTHONPATH.
try:
    from agent_sdk import MetaculusAsyncOpenAI
except ImportError:
    # Attempt to add project root to path if agent_sdk is not found
    # This is a common pattern for scripts within subdirectories of a project
    project_root = str(
        pathlib.Path(__file__).resolve().parents[3]
    )  # Adjust depth as needed
    if project_root not in sys.path:
        sys.path.insert(0, project_root)
    from agent_sdk import MetaculusAsyncOpenAI

# Assuming forecasting_tools is also in the root or a findable path
from forecasting_tools import GeneralLlm
from agents import function_tool, AgentOutputSchema


# Global constant for the web search LLM model
WEB_SEARCH_LLM_MODEL = "metaculus/gpt-4o-search-preview"  # Or your preferred model


@function_tool
async def web_search(query: str) -> str:
    """Searches the web for information about a given query."""
    print(f"\nüîé Performing web search for: '{query}'")
    # Assuming GeneralLlm can be initialized without a specific client for web search,
    # or that it defaults to a globally available one.
    # If MetaculusAsyncOpenAI client is needed for GeneralLlm, it must be passed or accessible.
    # For this tool, it seems to initialize its own model instance.
    model = GeneralLlm(model=WEB_SEARCH_LLM_MODEL, temperature=None)
    response = await model.invoke(query)
    print(f"\nüîç Search result: {response}")
    return response


# --- Pydantic Models for BN and Data Structures ---


class Node(BaseModel):
    name: str
    description: str
    states: Dict[str, str]
    parents: List[str] = Field(default_factory=list)
    cpt: Dict[str, Dict[str, float]] = (
        Field(  # CPT values should be floats (probabilities)
            default_factory=dict, description="The Conditional Probability Table."
        )
    )


class BNStructure(BaseModel):
    topic: str
    explanation: str
    nodes: Dict[str, Node] = Field(default_factory=dict)
    target_node_name: str = Field(
        description="The name of the node that directly answers the forecasting question."
    )


class ContextReport(BaseModel):
    """
    A report containing key facts, definitions, and the current context relevant to the forecasting topic.
    This information is verified with the latest available data.
    """

    verified_facts: List[str] = Field(
        description="A list of key facts and definitions that have been verified against the latest information."
    )
    summary: str = Field(
        description="A brief summary of the overall context based on the verified facts."
    )


class QualitativeCpt(BaseModel):
    """
    Holds the LLM's qualitative assessment of likelihoods for a node's CPT.
    The keys are parent state combinations, and the values are dictionaries
    mapping child states to a relative, non-normalized likelihood score (e.g., 1-100).
    """

    cpt_qualitative_estimates: Dict[str, Dict[str, int]] = Field(
        description="A dictionary where keys are string representations of parent state tuples, "
        "and values are dictionaries mapping child states to their relative likelihood scores."
    )
    justification: str = Field(
        description="A detailed explanation of the reasoning used to arrive at the estimates."
    )


# --- Agent Configuration Models ---


class ModelConfig(BaseModel):
    model_name: str
    # The openai_client should be Any to accommodate various client types,
    # but specifically MetaculusAsyncOpenAI in this context.
    # It's made optional here; the runner script will be responsible for providing it.
    openai_client: Optional[Any] = None


class AgentConfig(BaseModel):
    agent_class: Callable[..., Any]  # Type for an agent class (e.g., agents.Agent)
    model_settings: ModelConfig
    tools: List[Any] = Field(default_factory=list)
    output_schema: Optional[Any] = None  # e.g., AgentOutputSchema(ContextReport)
    instructions_template: str  # Base instructions template from pipeline_constants.py


# --- Main Pipeline Data Structure ---


class PipelineData(BaseModel):
    """
    A Pydantic model to hold and pass all data between pipeline steps.
    This ensures type safety and clear data contracts.
    """

    # Initial inputs
    topic: str

    # Data generated by ContextStep
    current_date: Optional[str] = None
    context_report: Optional[ContextReport] = None
    context_facts_str: Optional[str] = None
    context_summary: Optional[str] = None

    # Data generated by ArchitectStep
    bn_structure: Optional[BNStructure] = (
        None  # Will be populated with CPTs by CPTGenerationStep
    )

    # Data generated by FinalCalculationStep
    final_probabilities: Optional[Dict[str, float]] = None
    final_probabilities_str: Optional[str] = None  # String representation or error

    # Data generated by ForecasterStep
    forecaster_agent_output: Optional[str] = None

    # General fields
    error_message: Optional[str] = (
        None  # To accumulate errors if pipeline continues on some failures
    )

    # Allows other fields to be added if necessary, for extensibility, though explicit fields are preferred.
    # class Config:
    #     extra = "allow"
